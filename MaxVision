import math
import time
import os

import cv2
import numpy as np
import pyautogui
import pygame
import PyQt5.QtCore as QtCore
import PyQt5.QtGui as QtGui
import PyQt5.QtWidgets as QtWidgets
import sys

# Initialize Pygame
pygame.init()

# Function to calculate the distance between two points
def distance(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)


# Function to update the aiming cursor position based on the aimbot
def update_aim(aimbot_strength, max_distance, target_x, target_y, target_vx, target_vy):
    # Get the current mouse position
    mouse_x, mouse_y = pyautogui.position()

    # Calculate the distance between the aiming cursor and the target
    dist = distance(mouse_x, mouse_y, target_x, target_y)

    # Get the screen width and height
    screen_width, screen_height = pyautogui.size()

    # If the target is within the maximum distance, apply aimbot force
    if dist < max_distance:
        # Calculate the time it will take for the projectile to reach the target
        time_to_impact = dist / np.linalg.norm([target_vx, target_vy])

        # Calculate the future position of the target
        predicted_x = target_x + target_vx * time_to_impact
        predicted_y = target_y + target_vy * time_to_impact

        # Calculate the angle between the aiming cursor and the predicted target position
        angle = math.atan2(predicted_y - mouse_y, predicted_x - mouse_x)

        # Calculate the x and y components of the aimbot force
        force_x = aimbot_strength * math.cos(angle)
        force_y = aimbot_strength * math.sin(angle)

        # Update the aiming cursor position based on the aimbot force
        pyautogui.moveRel(force_x, force_y)

# Function to select the target pixel by pressing a hotkey and clicking on the target
def select_target_pixel(hotkey):
    # Flag to track whether the hotkey has been pressed
    hotkey_pressed = False

    # Flag to track whether a target pixel has been selected
    pixel_selected = False

    # Run a loop to listen for key press and mouse click events
    while not pixel_selected:
        # Process Pygame events
        for event in pygame.event.get():
            # Handle the Pygame quit event
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            # Handle key press events
            elif event.type == pygame.KEYDOWN:
                # Check if the hotkey was pressed
                if event.key == hotkey:
                    hotkey_pressed = True
            # Handle mouse click events
            elif event.type == pygame.MOUSEBUTTONDOWN:
                # Check if the hotkey has been pressed
                if hotkey_pressed:
                # Get the mouse position when the mouse was clicked
                    x, y = pygame.mouse.get_pos()
                    pixel_selected = True

    # Return the target pixel coordinates
    return x, y


# Function to find the target element in the game using image recognition
def find_target(screenshot, template_path):
    # Convert the screenshot to a grayscale image
    gray_image = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2GRAY)

    # Load the target image template
    template = cv2.imread(template_path, 0)

    # Use the matchTemplate function to find the target image in the screenshot
    result = cv2.matchTemplate(gray_image, template, cv2.TM_CCOEFF_NORMED)
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

    # If the target image was found in the screenshot, return the target coordinates
    if max_val > 0.8:
        return max_loc[0] + template.shape[1] // 2, max_loc[1] + template.shape[0] // 2
    else:
        return None, None


# Function to get the velocity of the target
def get_target_velocity(history, frame_time):
    # Calculate the time elapsed between the current and previous frames
    elapsed_time = frame_time - history[-1][2]

    # Calculate the x and y velocities of the target
    vx = (history[-1][0] - history[-2][0]) / elapsed_time
    vy = (history[-1][1] - history[-2][1]) / elapsed_time

    return vx, vy


# Main function
def main():
    # Set the hotkey for selecting the target pixel
    hotkey = pygame.K_SPACE

    # Set the aimbot strength and maximum distance
    aimbot_strength = 10
    max_distance = 200

    # Set the path to the target image template
    template_path = "template.png"

    # Set the frame rate of the game
    frame_rate = 240

    # Set the frame time in seconds
    frame_time = 1 / frame_rate

    # Set the maximum number of history entries to store
    max_history = 5

    # Set the starting time for calculating the frame rate
    start_time = time.time()

    # Create a Pygame window
    window = pygame.display.set_mode((0, 0))

    # Set the Pygame window title
    pygame.display.set_caption("Aimbot")

    # Create a Pygame clock to control the frame rate
    clock = pygame.time.Clock()

    # Create a list to store the history of target positions
    history = []

    # Run a loop to continuously capture game screenshots and update the aimbot
    while True:
        # Capture a screenshot of the game window
        screenshot = pyautogui.screenshot()

        # Find the target using image recognition
        target_x, target_y = find_target(screenshot, template_path)

                # If the target was found, add the target position to the history
        if target_x is not None and target_y is not None:
            # Append the target position and current time to the history list
            history.append((target_x, target_y, time.time()))

            # If the history list is longer than the maximum number of entries, remove the oldest entry
            if len(history) > max_history:
                history.pop(0)

            # If there are enough history entries to calculate the velocity, get the target velocity
            if len(history) >= 2:
                target_vx, target_vy = get_target_velocity(history, frame_time)
            else:
                target_vx, target_vy = 0, 0
        else:
            # If the target was not found, reset the history
            history = []
            target_vx, target_vy = 0, 0

        # Update the aiming cursor position based on the aimbot
        update_aim(aimbot_strength, max_distance, target_x, target_y, target_vx, target_vy)

        # Wait for the frame rate time to pass
        clock.tick(frame_rate)

        # Calculate the elapsed time
        elapsed_time = time.time() - start_time

        # If the elapsed time is greater than the frame time, print the frame rate
        if elapsed_time > frame_time:
            # Calculate the frame rate
            frame_rate = len(history) / elapsed_time

            # Reset the start time
            start_time = time.time()

# Run the main function
if __name__ == "__main__":
    main()
